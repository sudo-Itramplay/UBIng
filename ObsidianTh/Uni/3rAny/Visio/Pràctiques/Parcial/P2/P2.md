#Filtering #edgedetection #imageSmoothing #convolution

Segona pràctica de Visió Artificial, amb problemes i solucions

## Imports
```python
import numpy as np 
from skimage import io 
from matplotlib import pyplot as plt


from skimage.color import rgb2gray
from skimage.util import img_as_ubyte
from skimage import img_as_float
from skimage.transform import rescale
from skimage.transform import resize
from skimage import exposure
from scipy.ndimage import convolve
from skimage import filters, img_as_float, morphology
from skimage.filters import gaussian, median
from skimage.morphology import disk, rectangle, diamond
from skimage.feature import canny
from skimage.filters import sobel, prewitt

import warnings
warnings.filterwarnings("ignore")



```

# 1.-Image Smoothing and Convolution

## Histograma
### a) 4 plot de imatge i els 3 canals

```python
from skimage import io
from matplotlib import pyplot as plt
import numpy as np
from skimage import img_as_float
from skimage.color import rgb2gray

img_oryx = io.imread("images_notebook/oryx.jpg")
print(img_oryx.dtype)
print(img_oryx.shape)

# Create a 1x4 figure to display the image as well as the three color channels (as grayscale images)
fig, ax = plt.subplots(1, 4, figsize=(16, 5))

 # Display the original image
ax[0].imshow(img_oryx)
# Remove the ticks and axes
ax[0].axis("off")
# Add a title to the image
ax[0].set_title("Original Image")
img_oryx_r = img_oryx.copy()
img_oryx_r = img_oryx_r[:,:,0]
# Display the image
ax[1].imshow(img_oryx_r, cmap="gray", vmin=0, vmax=255)
# Remove the ticks and axes
ax[1].axis("off")
# Add a title to the image
ax[1].set_title("Red Channel")
img_oryx_g = img_oryx.copy()
img_oryx_g = img_oryx_g[:,:,1]
# Display the image
ax[2].imshow(img_oryx_g, cmap="gray", vmin=0, vmax=255)
# Remove the ticks and axes
ax[2].axis("off")
# Add a title to the image
ax[2].set_title("Green Channel")
img_oryx_b = img_oryx.copy()
img_oryx_b = img_oryx_b[:,:,2]
# Display the image
ax[3].imshow(img_oryx_b, cmap="gray", vmin=0, vmax=255)
# Remove the ticks and axes
ax[3].axis("off")
# Add a title to the image
ax[3].set_title("Blue Channel")
plt.show()
```

### b) Fer histogrames
Fes un histograma per visualitzar el RGB i les 3 grayscales d'abans

Has de fer que l'histograma pugui obtenir 16, 32, 64, 256 bins

>[!Note] What type should be the image in order to compute the histogram? 
>Check using different bins for the histogram.

>[!tip] the `exposure` module within the `skimage` library makes the histogram extraction easy!


>[!Help] 
>[matplotlib image tutorial](https://matplotlib.org/users/image_tutorial.html)

```python
from skimage import exposure

def im_hist(im, nbins=128):

# Convert the image to float (range between 0 and 1)
im = img_as_float(im)

# Compute the grayscale histogram using the specified number of bins
hist, bins = exposure.histogram(rgb2gray(im), nbins=nbins)

  

# Compute the histograms for the red, green, and blue channels
hist_r, bins_r = exposure.histogram(im[:, :, 0], nbins=nbins)

hist_g, bins_g = exposure.histogram(im[:, :, 1], nbins=nbins)

hist_b, bins_b = exposure.histogram(im[:, :, 2], nbins=nbins)

  
# Calculate width for the bar plot
width = 0.2 # Fixed width factor for bars


# Generate shifted x-axis values to prevent overlapping between channels
inds = np.arange(nbins) # Common indices for all histograms

bins_r = inds + width # Shift red histogram bars
bins_g = inds + 2 * width # Shift green histogram bars
bins_b = inds + 3 * width # Shift blue histogram bars 

# Create a figure with a defined size
plt.figure(figsize=(10, 4))

# Plot the histograms as bar plots with corresponding colors
plt.bar(inds, hist, width=width, color="gray", label="Gray") # Grayscale histogram

plt.bar(bins_r, hist_r, width=width, color="red", label="Red") # Red channel histogram

plt.bar(bins_g, hist_g, width=width, color="green", label="Green") # Green channel histogram

plt.bar(bins_b, hist_b, width=width, color="blue", label="Blue") # Blue channel histogram

# Add a legend to the plot
plt.legend()

# Show the plotg
plt.show()
```
  
>[!INFO] Explicació: Histograma
>* **Histograma (Gris):** Mostra la distribució global de la intensitat a la imatge.
>* **Historigrames (RGB):** Indica la quantitat de cada color (Vermell, Verd, Blau) per a cada nivell d'intensitat.
>* **Bins (Contenidors):** Defineixen la granularitat de l'histograma.

* **Pocs Bins (ex: 16, 32):** Vista generalitzada. Més fàcil veure tendències, però es perd detall fi.

* **Molts Bins (ex: 64, 256):** Major granularitat. Mostra detalls subtils, però pot ser més sorollós o difícil d'interpretar.

>[!TIP] Requeriment per al Càlcul
>Per calcular l'histograma (p.ex. amb `exposure.histogram()`), la imatge ha d'estar en format `float` i amb valors normalitzats (en el rang [0, 1]).

## Convolució

Amb la imatge:
![[oryx.jpg]]

### a) 3 tipus convolució
Reshape la imatge a 256x256 i converteixla a grayscale i fes:

- Convolve horitzontal
- Convolve vertical
- Convolve en les 2 direccions
També mira maxims i minims

---

>[!QUESTION] Influència de la Màscara (Kernel)
>
>* És important el tipus de màscara (kernel) per a la convolució?
>* Quin efecte produeix cada tipus de màscara sobre la imatge original?
>* Compara els resultats obtinguts.

---

>[!NOTE] Funció `convolve`
>La comanda `convolve` realitza una convolució multidimensional.
>* Un vector (màscara 1D) s'ha de representar com una matriu 2D, per exemple: `[[1, 1, 1]]`.

---

>[!TIP] Requeriment: Normalització de la Màscara
Abans d'aplicar la funció `convolve` (especialment per a filtres de suavitzat o mitjana), la màscara ha d'estar **normalitzada**.
>* Això significa que tots els valors de la màscara han de sumar **1**.

---

#### 1 - Imatge original
```python
from skimage.transform import resize
from scipy.ndimage import convolve

# Use skimage to scale the image oryx to a 256x256 image
oryx_resized = img_oryx.copy() # Here you can get the image previously loaded or load it again
oryx_resized = resize(oryx_resized, (256, 256))
oryx_gray = rgb2gray(oryx_resized)

# Print the minimum and maximum values of the resized image, as well as its data type
print("Original")
print("Min:", np.min(oryx_resized))
print("Max:", np.max(oryx_resized))
print("Data type:", oryx_resized.dtype)
```


#### 2 - H
```python
mask_h1d=[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
# Normalize the mask
mask_h1d = np.array(mask_h1d) / np.sum(mask_h1d)
oryx_h1d = convolve(oryx_gray, mask_h1d)
# Print the minimum and maximum values of the convolved image, as well as its data type
print("H1D")
print("Min:", np.min(oryx_h1d))
print("Max:", np.max(oryx_h1d))
print("Data type:", oryx_h1d.dtype)

```

#### 3 - V
```python
mask_h1d = mask_h1d.T
oryx_v1d = convolve(oryx_gray, mask_h1d)

# Print the minimum and maximum values of the convolved image, as well as its data type
print("V1D")
print("Min:", np.min(oryx_v1d))
print("Max:", np.max(oryx_v1d))
print("Data type:", oryx_v1d.dtype)
```

#### 4 - 2d
```python
mask_2d = np.ones((15, 15))
# Normalize the mask
mask_2d = mask_2d / np.sum(mask_2d)
oryx_2d = convolve(oryx_gray, mask_2d)

# Print the minimum and maximum values of the convolved image, as well as its data type
print("2D")
print("Min:", np.min(oryx_2d))
print("Max:", np.max(oryx_2d))
print("Data type:", oryx_2d.dtype)
```


### b) Plot en graella 2x2

```python
# Show all the images in a 2x2 grid
fig, ax = plt.subplots(2, 2, figsize=(10, 10))


#1
# Display the original image
ax[0, 0].imshow(oryx_gray, cmap="gray")
# Remove the ticks and axes
ax[0, 0].axis("off")
# Add a title to the image
ax[0, 0].set_title("Resized Image")


#2
# Display the horizontal 1D mask
ax[0, 1].imshow(oryx_h1d, cmap="gray")
# Remove the ticks and axes
ax[0, 1].axis("off")
# Add a title to the image
ax[0, 1].set_title("Horizontal 1D Mask")


#3
# Display the vertical 1D mask
ax[1, 0].imshow(oryx_v1d, cmap="gray")
# Remove the ticks and axes
ax[1, 0].axis("off")
# Add a title to the image
ax[1, 0].set_title("Vertical 1D Mask")


#4
# Display the 2D mask
ax[1, 1].imshow(oryx_2d, cmap="gray")
# Remove the ticks and axes
ax[1, 1].axis("off")
# Add a title to the image
ax[1, 1].set_title("2D Mask")

```

### c) Convolve RGB

```python
#your solution
def conv_coor(image, mask):
	# Apply the mask to each channel (R, G, B) separately
	result_image = np.zeros_like(image)
	
	for i in range(3):
		result_image[:, :, i] = convolve(image[:, :, i], mask/np.sum(mask))
	
	return result_image

  

mask_3d = np.ones((7, 7))
oryx_3d = conv_coor(img_as_float(oryx_resized), mask_3d)

plt.imshow(oryx_3d)
plt.axis("off")
plt.show()
```

---

## 1.2 - Histogrames reescalat

### a)
Què passa al aplicar rescale i fer el seu histograma a una imatge?

```python
from skimage.transform import rescale

# Plot the histogram of the image oryx_gray
hist, bins = exposure.histogram(oryx_gray, nbins=32)
plt.bar(255*bins, hist, width=2)
plt.show()
  
# Rescale (10 times smaller) the image oryx_gray
oryx_rescaled = oryx_gray.copy()
oryx_rescaled = rescale(oryx_rescaled, 1/20)
hist, bins = exposure.histogram(oryx_rescaled, nbins=32)

# Plot the histogram of the rescaled image
plt.bar(255*bins, hist, width=2)
# Set the x-axis limits to [0, 255]
plt.xlim([0, 255])
plt.show()

# Rescale (10 times bigger) the image oryx_gray
oryx_rescaled = oryx_gray.copy()
oryx_rescaled = rescale(oryx_rescaled, 20)

hist, bins = exposure.histogram(oryx_rescaled, nbins=32)
# Plot the histogram of the rescaled image
plt.bar(255*bins, hist, width=2)
plt.show()
```

>[!INFO] Histograma: Imatge Original (oryx_gray)
>* **Distribució:** Mostra la distribució d'intensitats (valors 0-255) en 64 *bins*.
>* **Concentració:** La majoria dels valors es concentren en el rang d'intensitat mitjana.

---

>[!WARNING] Efecte del "Downsampling" (Reducció x20)
>* **Resultat:** L'histograma es torna **dispers**.
>* **Causa:** El submostreig redueix dràsticament el detall. Moltes intensitats veïnes es fusionen o es fa una mitjana, resultant en menys valors d'intensitat diferents.
>* **Impacte:** La reducció de píxels totals fa que els pics de l'histograma siguin **més baixos i menys definits**.

---

>[!NOTE] Efecte del "Upsampling" (Ampliació x20)
>* **Resultat:** L'histograma **conserva la forma** de l'original, però amb pics (recompte de píxels) molt **més alts** a cada *bin*.
>* **Causa:** El procés d'interpolació afegeix nous píxels basant-se en els veïns.
>* **Impacte:** Augmenta el nombre total de píxels, però **no introdueix nous nivells d'intensitat**. Es preserva la distribució original.

---

### b) Aplica l'histograma a la convolució
```python

mask = np.ones((7,7))
mask = mask/np.sum(mask)

oryx_blurred = convolve(img_as_float(oryx_gray), mask)

oryx_small_blurred = convolve(rescale(img_as_float(oryx_gray), 1/20), mask)

oryx_big_blurred = convolve(rescale(img_as_float(oryx_gray), 20), mask)

# Compute histograms
hist, bins = exposure.histogram(oryx_blurred, nbins=32)

hist_small, bins_small = exposure.histogram(oryx_small_blurred, nbins=32)

hist_big, bins_big = exposure.histogram(oryx_big_blurred, nbins=32)

# Plot histograms
plt.bar(255*bins, hist, width=2, label="Original")
plt.xlim([0, 255])
plt.show()

plt.bar(255*bins_small, hist_small, width=0.5, label="Small")
plt.xlim([0, 255])
plt.show()

plt.bar(255*bins_big, hist_big, width=2, label="Big")
plt.xlim([0, 255])
plt.show()
```

---

>[!INFO] Efecte: Convolució Uniforme 7x7 (Imatge Original)
>* **Resultat a la Imatge:** L'efecte és un desenfocament (*blurring*), suavitzant els detalls d'alta freqüència (vores, transicions nítides).
>* **Causa:** Els valors dels píxels veïns es tornen més similars entre ells.
>* **Impacte a l'Histograma:** La variància de les intensitats es redueix. Es crea un pic més pronunciat en el rang d'intensitat mitjà (aprox. 120-150).

---

>[!WARNING] Efecte: Convolució sobre Imatge Reduïda (Downsampled)
>* **Imatge Reduïda:** Té menys píxels, resultant en un histograma més dispers (menys valors d'intensitat diferents).
>* **Impacte de la Convolució:** La convolució té menys efecte, ja que la imatge ja havia perdut molt de detall.
>* **Histograma Resultant:** Mostra un rang d'intensitats reduït i menys *bins* únics. Està més agrupat, reflectint la pèrdua de diversitat (p.ex., es perden valors per sota de 100).

---

>[!NOTE] Efecte: Convolució sobre Imatge Augmentada (Upsampled)
>* **Imatge Augmentada:** Conté molts més píxels que l'original.
>* **Histograma Resultant:** S'assembla molt a l'histograma original, però a una escala molt més gran (recompte de *bins* extremadament alt).
>* **Impacte de la Convolució:** Suavitza els detalls (desenfocament), però el rang d'intensitat **no** es torna més uniforme (a diferència de la convolució sobre l'original). La distribució general es manté similar a la de l'original.

---


## 1.3 Filtres no lineals

### a) Kernels Gauss i mediana
```python
from skimage import filters, img_as_float, morphology
from skimage.filters import gaussian, median
from skimage.morphology import disk, rectangle, diamond

  

# Convert image to float for better processing
oryx_gray_float = img_as_float(oryx_gray)

# 1. Apply Gaussian filter with sigma = 1
gaussian_sigma_1 = gaussian(oryx_gray_float, sigma=1)

# 2. Apply Gaussian filter with three different sigma values
gaussian_sigma_0_5 = gaussian(oryx_gray_float, sigma=0.5)

gaussian_sigma_2 = gaussian(oryx_gray_float, sigma=2)

gaussian_sigma_3 = gaussian(oryx_gray_float, sigma=3)

  

# 3. Apply median filters with different mask shapes
median_disk = median(oryx_gray_float, morphology.disk(5))

median_rectangle = median(oryx_gray_float, morphology.rectangle(5, 20))

median_diamond = median(oryx_gray_float, morphology.diamond(3))

  

# Plot results
fig, ax = plt.subplots(3, 3, figsize=(15, 15))
# Original Image
ax[0, 0].imshow(oryx_gray_float, cmap='gray')
ax[0, 0].set_title('Original Image')
ax[0, 0].axis('off')

# Gaussian with sigma = 1
ax[0, 1].imshow(gaussian_sigma_1, cmap='gray')
ax[0, 1].set_title('Gaussian sigma=1')
ax[0, 1].axis('off')

# Gaussian with sigma = 0.5
ax[0, 2].imshow(gaussian_sigma_0_5, cmap='gray')
ax[0, 2].set_title('Gaussian sigma=0.5')
ax[0, 2].axis('off')  

# Gaussian with sigma = 2
ax[1, 0].imshow(gaussian_sigma_2, cmap='gray')
ax[1, 0].set_title('Gaussian sigma=2')
ax[1, 0].axis('off')

# Gaussian with sigma = 3
ax[1, 1].imshow(gaussian_sigma_3, cmap='gray')
ax[1, 1].set_title('Gaussian sigma=3')
ax[1, 1].axis('off')
  
# Median filter with disk
ax[1, 2].imshow(median_disk, cmap='gray')
ax[1, 2].set_title('Median Disk Shape')
ax[1, 2].axis('off')

# Median filter with rectangle
ax[2, 0].imshow(median_rectangle, cmap='gray')
ax[2, 0].set_title('Median Rectangle Shape')
ax[2, 0].axis('off')

# Median filter with diamond
ax[2, 1].imshow(median_diamond, cmap='gray')
ax[2, 1].set_title('Median Diamond Shape')
ax[2, 1].axis('off')

ax[2, 2].axis('off')
plt.tight_layout()
plt.show()
```
![[Pasted image 20251026170209.png]]

#### Gauss
>[!INFO] Nucli Gaussià (Kernel) segons Sigma ($\sigma$)
* **Gaussià ($\sigma = 0.5$):**
    * **Efecte:** Suavitzat mínim.
    * **Detall (Banyes):** Preserva els detalls fins (banyes de l'òrix) i la nitidesa general. Lleugera reducció de soroll.
* **Gaussià ($\sigma = 1$):**
    * **Efecte:** Suavitzat moderat.
    * **Detall (Banyes):** Les banyes es preserven bé. Alguns detalls fins (p.ex., textura del pèl) es difuminen lleugerament.
    * **Resultat:** Bon equilibri entre reducció de soroll i retenció de detalls.
* **Gaussià ($\sigma = 2$):**
    * **Efecte:** Suavitzat prominent.
    * **Detall (Banyes):** Els detalls fins (banyes) comencen a difuminar-se. Les vores són menys definides i es perd textura.
* **Gaussià ($\sigma = 3$):**
    * **Efecte:** Difuminat excessiu.
    * **Detall (Banyes):** Les banyes i altres trets fins es perden gairebé completament, fusionant-se amb el fons.

---
#### Mediana
>[!INFO]  Filtres de Mediana segons la Forma (Mask)

* **Mediana (Forma: Disc):**
    * **Efecte:** Elimina bé el soroll mantenint estructures grans.
    * **Detall (Banyes):** **Es perden els detalls fins de les banyes.** La forma de disc suavitza excessivament les estructures fines i primes (com les banyes), fent que es barregin amb el cel.
 
* **Mediana (Forma: Rectangle):**
    * **Efecte:** Introdueix distorsions més pronunciades. Estira les característiques verticals i horitzontals.
    * **Detall (Banyes):** **Les banyes de l'òrix desapareixen.** Molt poc adequat per preservar trets fins.

* **Mediana (Forma: Diamant):**
    * **Efecte:** El millor equilibri dels filtres de mediana provats.
    * **Detall (Banyes):** Tot i que hi ha certa pèrdua de detall, les banyes romanen **més visibles** que amb les formes de disc o rectangle.


>[!tip] Triar la forma correcta
>pel filtre de mediana, depenent de la imatge, cada forma anirà diferent, has de provar quina perd menys informació


---
#### Resum gauss mediana
>[!SUMMARY] Resum dels Efectes dels Filtres

* **Filtres Gaussians:**
    * Produeixen un desenfocament progressiu (augmentant $\sigma$).
    * $\sigma = 0.5$ preserva bé les banyes.
    * $\sigma \ge 2$ difumina les banyes i estructures fines.
* **Filtres de Mediana:**
    * Generalment, preserven millor les vores que els Gaussians.
    * Les formes de **Disc** i **Rectangle** provoquen la pèrdua de les banyes.
    * La forma de **Diamant** preserva millor les banyes (en comparació amb les altres formes de mediana).







# 2.-Edge Detection

## 2.1 - Algorismes de contorn
### a)
Aplica:
- Prewitt
- Sobel
- Canny
Fes els plots i contesta les preguntes

```python
import warnings
warnings.filterwarnings("ignore")

"""Your Solution"""
from skimage.feature import canny
from skimage.filters import sobel, prewitt

  
  

logo = io.imread("images_notebook/logo_pozo.jpg")
plt.imshow(logo)
plt.axis("off")
plt.show()

  

logo_gray = rgb2gray(logo[:,:,:3])
logo_pre = prewitt(logo_gray)
logo_sob = sobel(logo_gray)
logo_canny = canny(logo_gray)

# Show all the images in a 1x4 grid
fig, ax = plt.subplots(1, 4, figsize=(20, 5))

  

# Display the original image
ax[0].imshow(logo_gray, cmap="gray")
# Remove the ticks and axes
ax[0].axis("off")
# Add a title to the image
ax[0].set_title("Original Image")
 

ax[1].imshow(logo_pre, cmap="gray")
ax[1].axis("off")
ax[1].set_title("Prewitt Filter")

ax[2].imshow(logo_sob, cmap="gray")
ax[2].axis("off")
ax[2].set_title("Sobel Filter")

ax[3].imshow(logo_canny, cmap="gray")
ax[3].axis("off")
ax[3].set_title("Canny Filter")
plt.show()
```
![[Pasted image 20251026171522.png]]


- Amb altres imatges
![[Pasted image 20251026172230.png]]

#### Sobreposem els contorns a la imatge
#plotTransparencia #opacidad #plotOpacidad
```python
# Superimpose contours on the original image
fig, ax = plt.subplots(1, 3, figsize=(15, 5))

# Prewitt contours
ax[0].imshow(logo, cmap='gray')
ax[0].imshow(logo_pre, cmap='hot', alpha=0.5) # Use transparency (alpha) to overlay edges
ax[0].set_title("Prewitt Edges Superimposed")
ax[0].axis('off')

# Sobel contours
ax[1].imshow(logo, cmap='gray')
ax[1].imshow(logo_sob, cmap='hot', alpha=0.5)
ax[1].set_title("Sobel Edges Superimposed")
ax[1].axis('off')

# Canny contours
ax[2].imshow(logo, cmap='gray')
ax[2].imshow(logo_canny, cmap='hot', alpha=0.5)
ax[2].set_title("Canny Edges Superimposed")
ax[2].axis('off')

plt.tight_layout()
plt.show()
```
![[Pasted image 20251026171655.png]]

##### Explicacions

- **Filtre de Prewitt:** És un mètode de detecció de vores simple. Les vores resultants són definides, però menys suaus que amb Sobel o Canny. Detecta bé el text principal ("EL POZO"), però perd detalls fins (com les corbes del "65"). Els contorns superposats són visibles però poc destacats; ofereix un perfilat bàsic, poc precís per a estructures complexes.

- **Filtre de Sobel:** Calcula gradients (horitzontal i vertical) per millorar la detecció, resultant en vores més suaus i definides que Prewitt. Els detalls (corbes del "65", text) són més nítids. És més adequat per a contorns amb elements corbs o diagonals. Els contorns superposats són més clars i destaquen millor les estructures.

- **Filtre de Canny:** És el mètode més sofisticat: combina suavitzat Gaussià amb detecció i seguiment de vores (histèresi). És excel·lent per detectar vores clares i contínues. Produeix el resultat més net i definit, capturant detalls precisos (logo, "65") amb soroll mínim. Els contorns superposats són els que més destaquen, ideals per a una detecció fina.

---

### Solució a les Qüestions

-  **Quina és la millor tècnica de detecció de contorns?** El filtre de **Canny** és la millor tècnica. Produeix les vores més netes i definides amb soroll mínim, sent ideal per a la detecció precisa de contorns en logos com el d'aquest exercici.

- **Quins són els paràmetres òptims per a aquesta imatge?** Per al filtre de Canny, un σ=1 (sigma) ofereix un bon equilibri entre reducció de soroll i claredat de la vora. (Més σ suavitzaria massa; menys σ introduiria soroll). El filtre de Sobel també funciona bé sense necessitat de paràmetres addicionals.

- **Cal normalitzar la màscara com fèiem en el filtratge per al suavitzat?** **No**, no és necessari normalitzar la màscara per a filtres de detecció de vores (Prewitt, Sobel, Canny). Aquests filtres es basen en el càlcul de gradients, no en la mitjana de valors de píxels (com sí que fan els filtres de suavitzat).

### b) Aplicar filtres abans de agafar bora

```python

from skimage.util import img_as_ubyte

def detect_edges(img, filter_x, filter_y, filters_normalized = False):

	"""
	
	Params:
	
	img: The image where the edges will be detected. It needs to be uint8
	
	and in the range of [0, 255]
	
	filter_x: the filter used to detect vertical edges. Can be normalized or not
	
	filter_y: the filter used to detect horizontal edges. Can be normalized or not
	
	filters_normalized: True if the coefficients are normalized, False otherwise
	
	Returns:
	
	edges_img: The image containing the edges. It will be uint8 and in the
	
	range of [0, 255]
	
	"""
	
	float_img = img_as_float(img)
	# Compute the derivatives in the x direction (i.e. vertical edges)
	vertical_edges_img = convolve(float_img, filter_x)
	# Compute the derivatives in the y direction (i.e. horizontal edges)
	horizontal_edges_img = convolve(float_img, filter_y)	
	# Compute the gradient magnitude (i.e. edge strength)
	edges_img = np.sqrt(vertical_edges_img**2 + horizontal_edges_img**2)
	
	""" Normalize the gradients to be in the range of [0.0, 1.0]
	
	if the filters were not normalized """

	if not filters_normalized:
		min_value = np.min(edges_img)
		max_value = np.max(edges_img)
		edges_img = (edges_img - min_value) / (max_value - min_value)
	return img_as_ubyte(edges_img)


# Masks

sobel_filter_x = np.array([[1, 0, -1],
[2, 0, -2],
[1, 0, -1]])

sobel_filter_y = np.array([[1, 2, 1],
[0, 0, 0],
[-1, -2, -1]])

prewitt_filter_x = np.array([[1, 0, -1],
[1, 0, -1],
[1, 0, -1]])

prewitt_filter_y = np.array([[1, 1, 1],
[0, 0, 0],
[-1, -1, -1]])

# Convolve with Sobel
sobel_edges_img = detect_edges(logo_gray, sobel_filter_x, sobel_filter_y)

# convolve with Prewit
prewitt_edges_img = detect_edges(logo_gray, prewitt_filter_x, prewitt_filter_y)

# Plot the images in a 2x2 grid
fig, ax = plt.subplots(2, 2, figsize=(10, 10))

# Built-in Prewitt
ax[0, 0].imshow(logo_pre, cmap='gray')
ax[0, 0].set_title("Built-in Prewitt Filter")
ax[0, 0].axis('off')

# Custom Prewitt
ax[0, 1].imshow(prewitt_edges_img, cmap='gray')
ax[0, 1].set_title("Custom Prewitt Filter")
ax[0, 1].axis('off')
  

# Built-in Sobel
ax[1, 0].imshow(logo_sob, cmap='gray')
ax[1, 0].set_title("Built-in Sobel Filter")
ax[1, 0].axis('off')
  

# Custom Sobel
ax[1, 1].imshow(sobel_edges_img, cmap='gray')
ax[1, 1].set_title("Custom Sobel Filter")
ax[1, 1].axis('off')
  

plt.tight_layout()
plt.show()

```

---
#### Preguntes
- **Filtre de Prewitt (Personalitzat vs. Integrat):** Els resultats del filtre de Prewitt personalitzat són molt similars a la implementació integrada. Les vores estan ben definides i la nitidesa és gairebé idèntica. Tot i que hi pot haver lleugeres variacions en la intensitat de les vores, el filtre personalitzat replica fidelment el mètode integrat.

- **Filtre de Sobel (Personalitzat vs. Integrat):** Els resultats del filtre de Sobel personalitzat són gairebé indistingibles de la versió integrada. Les vores són nítides i suaus, capturant els contorns i el text amb la mateixa precisió. Les diferències en la intensitat dels píxels a les vores són mínimes i no afecten la qualitat general de la detecció.
## 2.2 - Imatges hybrides

### a)Fes un filtre de baixa freqüència i un d'alta
```python
from skimage import io
from skimage.color import rgb2gray
from skimage.filters import gaussian
from skimage.transform import resize

messi = io.imread("images_notebook/messi.jpg")

# Resize to common size of 256x256
messi = resize(messi, (300, 300))
messi_low = gaussian(messi, sigma=4)
messi_high = messi - messi_low

# Show all the images in a 1x3 grid
fig, ax = plt.subplots(1, 3, figsize=(15, 5))

  

# Display the original image
ax[0].imshow(messi)
# Remove the ticks and axes
ax[0].axis("off")
# Add a title to the image
ax[0].set_title("Original Image")

ax[1].imshow(messi_low)
ax[1].axis("off")
ax[1].set_title("Low Frequencies")

ax[2].imshow(messi_high)
ax[2].axis("off")
ax[2].set_title("High Frequencies")
```

![[Pasted image 20251026174340.png]]


### b) Fes la imatge hibrida amb cr7 i messi

```python

#your solution
hybrid_2= 2*(0.5*messi_low + 0.5*cr_high)

hybrid_1 = 2*(0.5*cr_low + 0.5*messi_high)

# Show all the images in a 1x2 grid
fig, ax = plt.subplots(1, 2, figsize=(10, 5))

# Display the original image
ax[0].imshow(hybrid_1)
# Remove the ticks and axes
ax[0].axis("off"
# Add a title to the image
ax[0].set_title("Hybrid Image 1")

ax[1].imshow(hybrid_2)
ax[1].axis("off")
ax[1].set_title("Hybrid Image 2")
```

![[Pasted image 20251026174515.png]]



## 2.3 - Anonimitzar
```python
image = io.imread("images_notebook/car.png")
print(image.shape)

# Convert image to float (better for manipulation)
image_float = img_as_float(image)
# Define coordinates of the license plates (manually identified)
# Example: (start_row, start_col), (end_row, end_col) for two plates

license_plate_1 = ((250, 250), (275, 320)) # Example coordinates for first car's license plate
license_plate_2 = ((250, 500), (275, 590)) # Example coordinates for second car's license plate

# Function to anonymize license plate by applying a blur
def anonymize_region(image, top_left, bottom_right):
	""" Anonymizes the region by blurring it. """
	# Extract the region to be anonymized
	region = image[top_left[0]:bottom_right[0], top_left[1]:bottom_right[1]]
	# Apply Gaussian blur to the region
	mask_3d = np.ones((25, 25))
	blurred_region = conv_coor(region, mask_3d)
	
	# Replace the original region with the blurred one
	image[top_left[0]:bottom_right[0], top_left[1]:bottom_right[1]] = blurred_region


# Anonymize both license plates
anonymize_region(image_float, license_plate_1[0], license_plate_1[1])

anonymize_region(image_float, license_plate_2[0], license_plate_2[1])

# Plot the original and anonymized images side by side
fig, ax = plt.subplots(1, 2, figsize=(12, 6))

# Display original image
ax[0].imshow(image)
ax[0].set_title('Original Image')
ax[0].axis('off')

# Display anonymized image
ax[1].imshow(image_float)
ax[1].set_title('Anonymized Image')
ax[1].axis('off')

plt.tight_layout()
plt.show()

```

![[Pasted image 20251026174721.png]]

