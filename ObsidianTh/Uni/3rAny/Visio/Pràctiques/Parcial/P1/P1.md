Primera pràctica de Visió Artificial, amb problemes i solucions

## Imports
```python
import numpy as np 
from skimage import io 
from matplotlib import pyplot as plt


from skimage.color import rgb2gray
from skimage.util import img_as_ubyte
```

---
# Exc 1.- Image Creation and Bases

## 1.1 Bases d'imatges

### a)
Crea i visualitza una imatge 
```python
img = np.zeros((100,100), dtype=np.uint8)
plt.imshow(img, cmap='gray', vmin=0, vmax=255)
```

>[!tip] imshow
>Important el cmap per visualitzar correctament les dades

>[!note] Altres opcions destacades
>Eliminar completament eixos per a tot el document
>``` python
>plt.axis('off')
>```


### b)

Crea i visualitza imatge en escala de grisos
```python
img_rgb = np.zeros((100,100, 3), dtype=np.uint8)
plt.imshow(img_rgb)

img_gray = rgb2gray(img_rgb)
```

### c)
Recrea:
![[gray_grid.png]]

i després, de cada una, visualitza el valor dels elements de la primera fila

```python
img = np.zeros((100,100), dtype=np.uint8)

img1 = img.copy()
img1[:,50:] = 255

img2 = img.copy()
img2[50:,:] = 255

img3 = img.copy()
img3[:50,:50] = 255

  

fig, axes = plt.subplots(1, 3)

# Elimina els eixos "localment"
for ax in axes:
	ax.get_xaxis().set_visible(False)
	ax.get_yaxis().set_visible(False)

  

axes[0].imshow(img1, cmap='gray')

axes[1].imshow(img2, cmap='gray')

axes[2].imshow(img3, cmap='gray')

  

# Print first row of each image

print(img1[0,:])
print(img2[0,:])
print(img3[0,:])
```


### d)
Flipea la imatge per fer la ilusió "mirall"
(copia la seguent imatge)
![[mirror.png]]

```python
img_flipped = np.flipud(img3)

# or

img_flipped = img3[::-1,:]

  

plt.imshow(img_flipped, cmap='gray')
```

### e) 
Útilitza les imatges de [[#c)]] per crear:
![[color_grid.png]]

```python
img_color = np.zeros((100, 100, 3), dtype=np.uint8)

#unim imatges, cada una en el canal RGB corresponent
img_color[:, :, 0] = img1
img_color[:, :, 1] = img2
img_color[:, :, 2] = img3

  

ax = plt.gca()

ax.axes.xaxis.set_ticklabels([])
ax.axes.yaxis.set_ticklabels([])

  

plt.imshow(img_color)
plt.axis('off')
```


> [!tip] hstack i vstack
> 
> NumPy ofereix funcions molt directes per apilar arrays (imatges):
> 
> - `np.hstack((img1, img2))`: Apila les imatges horitzontalment.
>     
> - `np.vstack((img1, img2))`: Apila les imatges verticalment.
>     
>     Les dimensions han de ser compatibles per a l'eix on no s'apila.
>     



## 1.2 Càrrega i manipulació bàsica d'imatges

### a)
Guarda la imatge anteriorment generada

```python
io.imsave('img_color.png', img_color)
```


### b)

Carrega i visualitza una imatge des d'un fitxer. Posteriorment, mostra les seves dimensions i el valor del píxel a la posició (10, 10).

```python
img_color = io.imread('img_color.png')

  

# Print the shape of the image
print(img_color.shape)

  

# Print the value of the pixel at position (10, 10)
print(img_color[10, 10])

  

# Print the data type of the image
print(img_color.dtype)
```

> [!tip] imread
> 
> La funció io.imread() de skimage carrega una imatge en un array de NumPy. Si la imatge és en color, l'array tindrà 3 dimensions: (alçada, amplada, canals_de_color). Si és en escala de grisos, en tindrà 2: (alçada, amplada).

## 1.3 Manipulació de Color

Converteix la imatge carregada a escala de grisos i mostra les dades, visualitza-la.
![[panda.jpg]]

```python
#Your solution

img_panda = io.imread('images_notebook/panda.jpg')

# Print dimension

print(img_panda.shape)

# Print data type

print(img_panda.dtype)

  

plt.imshow(img_panda)

# Remove axis (optional)

plt.axis('off')

  
  

### Note

from skimage.color import rgb2gray

# Per mostrar en RGB:

## plt.imshow(img_panda)

# Mostrar en escala de grisos (grayscale):

img_gray = rgb2gray(img_panda)

plt.imshow(img_gray, cmap='gray')




  

img_gray = rgb2gray(img_panda)

# Save the image

io.imsave('panda_gray.jpg', img_as_ubyte(img_gray))

  

# Show in a 1x2 grid the RGB and the grayscale image

fig, axes = plt.subplots(1, 2, figsize=(10, 5))

  

for ax in axes:

ax.get_xaxis().set_visible(False)

ax.get_yaxis().set_visible(False)

# Or ax.axis('off')

  

axes[0].imshow(img_panda)

axes[1].imshow(img_gray, cmap='gray')
```

> [!note] Tipus de dades en conversió
> 
> La funció rgb2gray retorna una imatge de tipus float amb valors en el rang [0, 1]. Per això és important utilitzar cmap='gray' a imshow per a una correcta visualització.

---

## Exc 2.- Càrrega i manipulació de color

### a) Càrrega i anàlisi

Carrega les imatges `model.png` i `coat.png`. Visualitza-les i mostra'n les dimensions.

Python

```
# Carreguem les imatges
img_model = io.imread('model.png')
img_coat = io.imread('coat.png')

# Mostrem les dimensions
print(f"Dimensions del model: {img_model.shape}")
print(f"Dimensions de l'abric: {img_coat.shape}")

# Visualitzem
fig, axes = plt.subplots(1, 2)
axes[0].imshow(img_model)
axes[0].set_title('Model')
axes[0].axis('off')

axes[1].imshow(img_coat)
axes[1].set_title('Coat')
axes[1].axis('off')

plt.show()
```

### b) Canals de color

De la imatge `model.png`, separa i visualitza els seus tres canals de color (R, G, B) de manera individual.

Python

```
# Separem els canals de la imatge del model
R = img_model[:, :, 0]
G = img_model[:, :, 1]
B = img_model[:, :, 2]

# Preparem la figura per a la visualització
fig, axes = plt.subplots(1, 3, figsize=(15, 5))
titles = ['Canal Vermell', 'Canal Verd', 'Canal Blau']
channels = [R, G, B]

for i, ax in enumerate(axes):
    ax.imshow(channels[i], cmap='gray')
    ax.set_title(titles[i])
    ax.axis('off')

plt.show()
```

> [!note] Visualització de canals
> 
> Un canal de color individual és una matriu 2D, és a dir, una imatge en escala de grisos. Per això, per visualitzar-lo correctament amb imshow, hem d'utilitzar un mapa de color com cmap='gray'.

---

## Exc 3.- Superposició d'imatges amb màscares

Aquest exercici final consisteix a superposar imatges en regions concretes definides per una màscara. Treballarem amb dues versions: superposar l'abric original i superposar una textura.

### a) Preparació: Càrrega de màscara i textura

Carrega la imatge de la màscara (`mask.png`) i la de la textura (`texture.png`). Crea una màscara booleana a partir de `mask.png`.

Python

```
# Carreguem els fitxers addicionals
mask_img = io.imread('mask.png')
img_texture = io.imread('texture.png')

# La màscara booleana serà True on la imatge de màscara tingui valors > 0
# Això selecciona els píxels que NO són negres.
mask = mask_img > 0

# Visualitzem la màscara per comprovar
plt.imshow(mask, cmap='gray')
plt.title('Màscara Booleana')
plt.axis('off')
```

### b) Superposició de l'abric original (`coat.png`)

Fes servir la màscara per "retallar" l'abric de `coat.png` i posar-lo sobre `model.png`.

Python

```
# És crucial que les imatges tinguin les mateixes dimensions
# En aquest cas, ja les tenen (1024, 768)

# Creem una còpia de la imatge del model per no sobreescriure l'original
img_model_coat = img_model.copy()

# Fem servir la màscara per assignar els píxels de l'abric
# Només en la regió de la màscara.
img_model_coat[mask] = img_coat[mask]

# Mostrem el resultat
plt.imshow(img_model_coat)
plt.title('Model amb l\'abric superposat')
plt.axis('off')
```

### c) Superposició de la textura (`texture.png`)

Ara, en lloc de l'abric, aplica la textura a la zona de l'abric sobre el model.

Python

```
from skimage.transform import resize
from skimage import img_as_ubyte

# La textura té dimensions diferents, l'hem de redimensionar
img_texture_resized = resize(img_texture, img_model.shape[:2])

# La funció resize retorna valors float [0,1]. La convertim a uint8 [0,255]
img_texture_resized = img_as_ubyte(img_texture_resized)


# Creem una nova còpia del model original
img_model_texture = img_model.copy()

# Apliquem la textura redimensionada utilitzant la mateixa màscara
img_model_texture[mask] = img_texture_resized[mask]


# Mostrem el resultat final
plt.imshow(img_model_texture)
plt.title('Model amb la textura aplicada')
plt.axis('off')
```

> [!summary] Resum de la tècnica
> 
> L'ús de màscares booleanes per a l'indexació és una de les tècniques més potents de NumPy i, per extensió, del processament d'imatges. Permet seleccionar i modificar regions complexes d'una imatge de forma extremadament eficient i amb un codi molt llegible. El procediment és:
> 
> 1. **Crear una màscara**: Un array de la mateixa mida que la imatge amb valors `True` a les zones d'interès i `False` a la resta.
>     
> 2. **Aplicar la màscara**: Utilitzar-la per indexar tant la imatge de destí com la d'origen (`desti[mask] = origen[mask]`).


> [!summary] Conclusió del problema
> 
> Aquest exercici combina múltiples tècniques fonamentals en visió per computador:
> 
> 1. **Càrrega d'imatges**: `io.imread`.
>     
> 2. **Creació de màscares**: Selecció de regions d'interès mitjançant condicions lògiques sobre els valors dels píxels.
>     
> 3. **Manipulació de dimensions**: `resize` per ajustar la mida de les imatges.
>     
> 4. **Indexació booleana**: Ús d'una màscara per modificar selectivament els píxels d'una imatge (`img[mask] = ...`). Aquesta és una tècnica extremadament potent i eficient.
>