# Image Segmentation and Video

  

Es parlen de 3 grans Tòpics:
- [[#Segmentation of Images]]

  - [[#Video Segmentation]]

 - [[#Background Substracion]]


# Segmentation of Images

## Felzenszwalb

Segmentació segons graf

```python
seg.felzenszwalb(image, scale=100 ,sigma=0.5, min_size=50)
```

### Paràmetres

- `Image`:
La imatge a la que se li aplica la segmentació
	- Pot estar, o  no, en gray scale (Pot ajudar en algun cas)
	- Pot ser entera o no.
		Si és float normalitzar


- `scale` (float)
Què tant grans han de ser els clusters (agrupacions) 
	+ Per juntar segments de colors raonablement semblants: 
		100- 500
	+ Per juntar pixels, molt més concret
		1-10

  (1 per defecte)

- `Sigma` (float)
Què tant s'emborrona la imatge abans d'aplicar filtre, 
	treu detall per juntar més facilment clusters en que hi hagi detallets que no ens interessen

valors tipics:
	entre 0.5 i 2

- `min_size` (int)
mida minima que ha de tenir un segment:
	Parametres "grans" són valors de 100
	per més detall es sol fer 20

S'ha de variar bastant scale per veure que es fa més gran


## QuickShift

Mètode de Segmentació que funciona trobant modes (pics) en l'espai de densitat dels píxels (basat en color i posició). És un mètode jeràrquic, però també és **computacionalment molt costós** (lent).

Pot tardar minuts (ara veuràs valors petits per accelerar-ho)

```python
segmented_qs = seg.quickshift(float_howart, kernel_size=4, max_dist=6, ratio=0.5)
```

### Paràmetres

  * `image` (float): La imatge d'entrada. 
  És molt recomanable que sigui RGB (color) i normalitzada a float.




* `kernel_size` (float): 
La mida (amplada) del nucli (kernel) Gaussià utilitzat per estimar la densitat.
* **Com s'utilitza:** Un `kernel_size` **més petit** detecta detalls més fins, però crea més segments i és més lent. Un valor **més gran** suavitza més la imatge i crea segments més grans i homogenis.

* `max_dist` (float):
El llindar de distància màxima. És el paràmetre clau per controlar el nombre de segments.
* **Com s'utilitza:** Un `max_dist` **més petit** fa que l'algorisme sigui més estricte, exigint que els píxels estiguin molt a prop (en color i espai) per agrupar-se. Això resulta en **molts més segments**. Un valor **més gran** permet agrupar píxels més llunyans, creant menys segments.

* `ratio` (float, 0-1): 
Controla el pes entre la distància de color i la distància espacial (posició).
* **Com s'utilitza:** `ratio=1` només té en compte el color. `ratio=0` només té en compte la posició (creant una graella). `ratio=0.5` (per defecte) dona la mateixa importància a tots dos.

  

**Quan s'utilitza?** Quickshift és útil quan no saps quants segments hi ha i vols un mètode que trobi agrupacions "naturals". El seu principal inconvenient és la velocitat; no és adequat per a imatges grans o aplicacions en temps real.


## SLIC
És ràpid, eficient en memòria i agrupa els píxels en regions (superpíxels) que són **compactes** i **de mida similar**, respectant els contorns.
### Paràmetres (SLIC)
* `image` (float): 
La imatge d'entrada. 
Ha d'estar en format **float**. 
SLIC està dissenyat per funcionar molt bé amb imatges en color (RGB).

* `n_segments` (int): 
El **nombre aproximat** de segments (superpíxels) que vols obtenir.
* **Com s'utilitza:** Aquest és el paràmetre més intuïtiu. Si vols més detall, augmenta aquest número. Si vols segments més grans, disminueix-lo.

* `compactness` (float): 
Controla l'equilibri entre la similitud de color i la proximitat espacial.
* **Com s'utilitza:** Un valor de `compactness` **més alt** força els superpíxels a ser més quadrats/compactes (més semblants a una graella). Un valor **més baix** permet que els segments s'adaptin més a les formes i contorns de la imatge, resultant en formes més irregulars.

* `sigma` (float): 
L'amplada del filtre Gaussià que s'aplica **abans** de la segmentació (concepte de P2, suavitzat).
* **Com s'utilitza:** Serveix per reduir el soroll. Un valor de `1` o `2` pot ajudar a prevenir que el soroll creï segments petits i innecessaris. Si `sigma=0`, no s'aplica suavitzat.

  
**Quan s'utilitza?** SLIC és excel·lent com a pas de preprocessament. És ideal quan vols reduir la complexitat de la imatge, passant de milions de píxels a uns pocs centenars de "regions" (superpíxels) sobre les quals després pots aplicar altres algorismes (com la classificació).
















# Video Segmentation
Necessita ser un video (folder d'imatges) Per tal de ser processat
No és un mètode per se, és un seguit de mètodes que, donat un threshold, divideix el video en segments quan canvia de pla

```python
def detect_shot_boundaries(differences, threshold=None):
	"""
	Detecta tots els frames on la diferència supera un llindar global.
	"""
	
	if threshold is None:
		# Llindar global: mitjana + 1 desviació estàndard
		threshold = np.mean(differences) + np.std(differences)
	
	# Retorna tots els índexs 'i' on D(i) > T
	shot_boundaries = [i for i, diff in enumerate(differences) if diff > threshold]
	
	return shot_boundaries, threshold
```











# Background Substracion
També és necessari  que sigui un video

Extreu background i foreground fent us de la mediana (com una càmara antiga)