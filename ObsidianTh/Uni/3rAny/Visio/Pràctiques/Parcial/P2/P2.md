#Filtering #edgedetection #imageSmoothing #convolution

Segona pràctica de Visió Artificial, amb problemes i solucions

## Imports
```python
import numpy as np 
from skimage import io 
from matplotlib import pyplot as plt


from skimage.color import rgb2gray
from skimage.util import img_as_ubyte
from skimage import img_as_float
from skimage.transform import rescale
from skimage.transform import resize
from skimage import exposure
from scipy.ndimage import convolve
```

# 1.-Image Smoothing and Convolution

## Histograma
### a) 4 plot de imatge i els 3 canals

```python
from skimage import io
from matplotlib import pyplot as plt
import numpy as np
from skimage import img_as_float
from skimage.color import rgb2gray

img_oryx = io.imread("images_notebook/oryx.jpg")
print(img_oryx.dtype)
print(img_oryx.shape)

# Create a 1x4 figure to display the image as well as the three color channels (as grayscale images)
fig, ax = plt.subplots(1, 4, figsize=(16, 5))

 # Display the original image
ax[0].imshow(img_oryx)
# Remove the ticks and axes
ax[0].axis("off")
# Add a title to the image
ax[0].set_title("Original Image")
img_oryx_r = img_oryx.copy()
img_oryx_r = img_oryx_r[:,:,0]
# Display the image
ax[1].imshow(img_oryx_r, cmap="gray", vmin=0, vmax=255)
# Remove the ticks and axes
ax[1].axis("off")
# Add a title to the image
ax[1].set_title("Red Channel")
img_oryx_g = img_oryx.copy()
img_oryx_g = img_oryx_g[:,:,1]
# Display the image
ax[2].imshow(img_oryx_g, cmap="gray", vmin=0, vmax=255)
# Remove the ticks and axes
ax[2].axis("off")
# Add a title to the image
ax[2].set_title("Green Channel")
img_oryx_b = img_oryx.copy()
img_oryx_b = img_oryx_b[:,:,2]
# Display the image
ax[3].imshow(img_oryx_b, cmap="gray", vmin=0, vmax=255)
# Remove the ticks and axes
ax[3].axis("off")
# Add a title to the image
ax[3].set_title("Blue Channel")
plt.show()
```

### b) Fer histogrames
Fes un histograma per visualitzar el RGB i les 3 grayscales d'abans

Has de fer que l'histograma pugui obtenir 16, 32, 64, 256 bins

>[!Note] What type should be the image in order to compute the histogram? 
>Check using different bins for the histogram.

>[!tip] the `exposure` module within the `skimage` library makes the histogram extraction easy!


>[!Help] 
>[matplotlib image tutorial](https://matplotlib.org/users/image_tutorial.html)

```python
from skimage import exposure

def im_hist(im, nbins=128):

# Convert the image to float (range between 0 and 1)
im = img_as_float(im)

# Compute the grayscale histogram using the specified number of bins
hist, bins = exposure.histogram(rgb2gray(im), nbins=nbins)

  

# Compute the histograms for the red, green, and blue channels
hist_r, bins_r = exposure.histogram(im[:, :, 0], nbins=nbins)

hist_g, bins_g = exposure.histogram(im[:, :, 1], nbins=nbins)

hist_b, bins_b = exposure.histogram(im[:, :, 2], nbins=nbins)

  
# Calculate width for the bar plot
width = 0.2 # Fixed width factor for bars


# Generate shifted x-axis values to prevent overlapping between channels
inds = np.arange(nbins) # Common indices for all histograms

bins_r = inds + width # Shift red histogram bars
bins_g = inds + 2 * width # Shift green histogram bars
bins_b = inds + 3 * width # Shift blue histogram bars 

# Create a figure with a defined size
plt.figure(figsize=(10, 4))

# Plot the histograms as bar plots with corresponding colors
plt.bar(inds, hist, width=width, color="gray", label="Gray") # Grayscale histogram

plt.bar(bins_r, hist_r, width=width, color="red", label="Red") # Red channel histogram

plt.bar(bins_g, hist_g, width=width, color="green", label="Green") # Green channel histogram

plt.bar(bins_b, hist_b, width=width, color="blue", label="Blue") # Blue channel histogram

# Add a legend to the plot
plt.legend()

# Show the plotg
plt.show()
```
  
>[!INFO] Explicació: Histograma
>* **Histograma (Gris):** Mostra la distribució global de la intensitat a la imatge.
>* **Historigrames (RGB):** Indica la quantitat de cada color (Vermell, Verd, Blau) per a cada nivell d'intensitat.
>* **Bins (Contenidors):** Defineixen la granularitat de l'histograma.

* **Pocs Bins (ex: 16, 32):** Vista generalitzada. Més fàcil veure tendències, però es perd detall fi.

* **Molts Bins (ex: 64, 256):** Major granularitat. Mostra detalls subtils, però pot ser més sorollós o difícil d'interpretar.

>[!TIP] Requeriment per al Càlcul
>Per calcular l'histograma (p.ex. amb `exposure.histogram()`), la imatge ha d'estar en format `float` i amb valors normalitzats (en el rang [0, 1]).

## Convolució

Amb la imatge:
![[oryx.jpg]]

### a) 3 tipus convolució
Reshape la imatge a 256x256 i converteixla a grayscale i fes:

- Convolve horitzontal
- Convolve vertical
- Convolve en les 2 direccions
També mira maxims i minims

---

>[!QUESTION] Influència de la Màscara (Kernel)
>
>* És important el tipus de màscara (kernel) per a la convolució?
>* Quin efecte produeix cada tipus de màscara sobre la imatge original?
>* Compara els resultats obtinguts.

---

>[!NOTE] Funció `convolve`
>La comanda `convolve` realitza una convolució multidimensional.
>* Un vector (màscara 1D) s'ha de representar com una matriu 2D, per exemple: `[[1, 1, 1]]`.

---

>[!TIP] Requeriment: Normalització de la Màscara
Abans d'aplicar la funció `convolve` (especialment per a filtres de suavitzat o mitjana), la màscara ha d'estar **normalitzada**.
>* Això significa que tots els valors de la màscara han de sumar **1**.

---

#### 1 - Imatge original
```python
from skimage.transform import resize
from scipy.ndimage import convolve

# Use skimage to scale the image oryx to a 256x256 image
oryx_resized = img_oryx.copy() # Here you can get the image previously loaded or load it again
oryx_resized = resize(oryx_resized, (256, 256))
oryx_gray = rgb2gray(oryx_resized)

# Print the minimum and maximum values of the resized image, as well as its data type
print("Original")
print("Min:", np.min(oryx_resized))
print("Max:", np.max(oryx_resized))
print("Data type:", oryx_resized.dtype)
```


#### 2 - H
```python
mask_h1d=[[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
# Normalize the mask
mask_h1d = np.array(mask_h1d) / np.sum(mask_h1d)
oryx_h1d = convolve(oryx_gray, mask_h1d)
# Print the minimum and maximum values of the convolved image, as well as its data type
print("H1D")
print("Min:", np.min(oryx_h1d))
print("Max:", np.max(oryx_h1d))
print("Data type:", oryx_h1d.dtype)

```

#### 3 - V
```python
mask_h1d = mask_h1d.T
oryx_v1d = convolve(oryx_gray, mask_h1d)

# Print the minimum and maximum values of the convolved image, as well as its data type
print("V1D")
print("Min:", np.min(oryx_v1d))
print("Max:", np.max(oryx_v1d))
print("Data type:", oryx_v1d.dtype)
```

#### 4 - 2d
```python
mask_2d = np.ones((15, 15))
# Normalize the mask
mask_2d = mask_2d / np.sum(mask_2d)
oryx_2d = convolve(oryx_gray, mask_2d)

# Print the minimum and maximum values of the convolved image, as well as its data type
print("2D")
print("Min:", np.min(oryx_2d))
print("Max:", np.max(oryx_2d))
print("Data type:", oryx_2d.dtype)
```


### b) Plot en graella 2x2

```python
# Show all the images in a 2x2 grid
fig, ax = plt.subplots(2, 2, figsize=(10, 10))


#1
# Display the original image
ax[0, 0].imshow(oryx_gray, cmap="gray")
# Remove the ticks and axes
ax[0, 0].axis("off")
# Add a title to the image
ax[0, 0].set_title("Resized Image")


#2
# Display the horizontal 1D mask
ax[0, 1].imshow(oryx_h1d, cmap="gray")
# Remove the ticks and axes
ax[0, 1].axis("off")
# Add a title to the image
ax[0, 1].set_title("Horizontal 1D Mask")


#3
# Display the vertical 1D mask
ax[1, 0].imshow(oryx_v1d, cmap="gray")
# Remove the ticks and axes
ax[1, 0].axis("off")
# Add a title to the image
ax[1, 0].set_title("Vertical 1D Mask")


#4
# Display the 2D mask
ax[1, 1].imshow(oryx_2d, cmap="gray")
# Remove the ticks and axes
ax[1, 1].axis("off")
# Add a title to the image
ax[1, 1].set_title("2D Mask")

```

### c) Convolve RGB

```python
#your solution
def conv_coor(image, mask):
	# Apply the mask to each channel (R, G, B) separately
	result_image = np.zeros_like(image)
	
	for i in range(3):
		result_image[:, :, i] = convolve(image[:, :, i], mask/np.sum(mask))
	
	return result_image

  

mask_3d = np.ones((7, 7))
oryx_3d = conv_coor(img_as_float(oryx_resized), mask_3d)

plt.imshow(oryx_3d)
plt.axis("off")
plt.show()
```




# 2.-Edge Detection