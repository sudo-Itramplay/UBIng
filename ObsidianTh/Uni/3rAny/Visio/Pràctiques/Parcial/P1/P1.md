#masks #RGB #plots #rescale

Primera pràctica de Visió Artificial, amb problemes i solucions

## Imports
```python
import numpy as np 
from skimage import io 
from matplotlib import pyplot as plt


from skimage.color import rgb2gray
from skimage.util import img_as_ubyte
from skimage.transform import rescale
from skimage.transform import resize
```

---
# Exc 1.- Image Creation and Bases

## 1.1 Bases d'imatges

### a)
Crea i visualitza una imatge 
```python
img = np.zeros((100,100), dtype=np.uint8)
plt.imshow(img, cmap='gray', vmin=0, vmax=255)
```

>[!tip] imshow
>Important el cmap per visualitzar correctament les dades

>[!note] Altres opcions destacades
>Eliminar completament eixos per a tot el document
>``` python
>plt.axis('off')
>```


### b)

Crea i visualitza imatge en escala de grisos
```python
img_rgb = np.zeros((100,100, 3), dtype=np.uint8)
plt.imshow(img_rgb)

img_gray = rgb2gray(img_rgb)
```

### c)
Recrea:
![[gray_grid.png]]

i després, de cada una, visualitza el valor dels elements de la primera fila

```python
img = np.zeros((100,100), dtype=np.uint8)

img1 = img.copy()
img1[:,50:] = 255

img2 = img.copy()
img2[50:,:] = 255

img3 = img.copy()
img3[:50,:50] = 255

  

fig, axes = plt.subplots(1, 3)

# Elimina els eixos "localment"
for ax in axes:
	ax.get_xaxis().set_visible(False)
	ax.get_yaxis().set_visible(False)

  

axes[0].imshow(img1, cmap='gray')

axes[1].imshow(img2, cmap='gray')

axes[2].imshow(img3, cmap='gray')

  

# Print first row of each image

print(img1[0,:])
print(img2[0,:])
print(img3[0,:])
```


### d)
Flipea la imatge per fer la ilusió "mirall"
(copia la seguent imatge)
![[mirror.png]]

```python
img_flipped = np.flipud(img3)

# or

img_flipped = img3[::-1,:]

  

plt.imshow(img_flipped, cmap='gray')
```

### e) 
Útilitza les imatges de [[#c)]] per crear:
![[color_grid.png]]

```python
img_color = np.zeros((100, 100, 3), dtype=np.uint8)

#unim imatges, cada una en el canal RGB corresponent
img_color[:, :, 0] = img1
img_color[:, :, 1] = img2
img_color[:, :, 2] = img3

  

ax = plt.gca()

ax.axes.xaxis.set_ticklabels([])
ax.axes.yaxis.set_ticklabels([])

  

plt.imshow(img_color)
plt.axis('off')
```


> [!tip] hstack i vstack
> 
> NumPy ofereix funcions molt directes per apilar arrays (imatges):
> 
> - `np.hstack((img1, img2))`: Apila les imatges horitzontalment.
>     
> - `np.vstack((img1, img2))`: Apila les imatges verticalment.
>     
>     Les dimensions han de ser compatibles per a l'eix on no s'apila.
>     


------
## 1.2 Càrrega i Guardat d'Imatges

### a) Guardar imatge
Guarda la imatge anteriorment generada

```python
io.imsave('img_color.png', img_color)
```


### b) carregar i visualitzar

Carrega i visualitza una imatge des d'un fitxer. Posteriorment, mostra les seves dimensions i el valor del píxel a la posició (10, 10).

```python
img_color = io.imread('img_color.png')

  

# Print the shape of the image
print(img_color.shape)

  

# Print the value of the pixel at position (10, 10)
print(img_color[10, 10])

  

# Print the data type of the image
print(img_color.dtype)
```

> [!tip] imread
> 
> La funció io.imread() de skimage carrega una imatge en un array de NumPy. Si la imatge és en color, l'array tindrà 3 dimensions: (alçada, amplada, canals_de_color). Si és en escala de grisos, en tindrà 2: (alçada, amplada).


----

## 1.3 Manipulació de Color

### a) rgb2grayscale
Converteix la imatge carregada a escala de grisos i mostra les dades, visualitza-la.
![[panda.jpg]]

>[!bug] Pseudocolors
>El "pseudocolor" apareix quan intentes visualitzar l'array 2D (escala de grisos). 
>
>Per defecte, `matplotlib` no sap que és una imatge en blanc i negre; pensa que és un mapa de calor (heatmap). Per tant, li aplica un **mapa de colors** (colormap) per defecte (normalment un anomenat 'viridis', que va de lila a groc).

>[!done] Solució:
>cmap='gray'. Així indiques a `matplotlib` que és en escala de grisos

```python
#Your solution

img_panda = io.imread('images_notebook/panda.jpg')

# Print dimension
print(img_panda.shape)

# Print data type
print(img_panda.dtype)

  

plt.imshow(img_panda)

# Remove axis (optional)
plt.axis('off')

  
  

### Note
from skimage.color import rgb2gray

# Per mostrar en RGB:
## plt.imshow(img_panda)

# Mostrar en escala de grisos (grayscale):
img_gray = rgb2gray(img_panda)
plt.imshow(img_gray, cmap='gray')

# Save the image
io.imsave('panda_gray.jpg', img_as_ubyte(img_gray))

  

# Show in a 1x2 grid the RGB and the grayscale image
fig, axes = plt.subplots(1, 2, figsize=(10, 5))

  

for ax in axes:
	ax.get_xaxis().set_visible(False)
	ax.get_yaxis().set_visible(False)

# Or ax.axis('off')

axes[0].imshow(img_panda)
axes[1].imshow(img_gray, cmap='gray')
```

> [!note] Tipus de dades en conversió
> 
> La funció rgb2gray retorna una imatge de tipus float amb valors en el rang [0, 1]. Per això és important utilitzar cmap='gray' a imshow per a una correcta visualització.

### b) plot 2 imatges

En un sol gràfic posa la imatge en grayscale i en color

```python

from skimage.util import img_as_ubyte

img_gray = rgb2gray(img_panda)

# Save the image
io.imsave('panda_gray.jpg', img_as_ubyte(img_gray))


# Show in a 1x2 grid the RGB and the grayscale image
fig, axes = plt.subplots(1, 2, figsize=(10, 5))

for ax in axes:
	ax.get_xaxis().set_visible(False)
	ax.get_yaxis().set_visible(False)

# Or ax.axis('off')

  

axes[0].imshow(img_panda)
axes[1].imshow(img_gray, cmap='gray')


```

### c) info imatge
Calcula la mitjana del grayscale i obten una imatge booleana:
```python

# Compute the mean of the image img_gray
mean = np.mean(img_gray)

# Binary thresholding
img_binary = img_gray > mean


plt.imshow(img_binary, cmap='gray')

```


### d) plot 3 imatges
Visualitza les 3 últimes imatges i assigna'ls un títol
```python

# Show the three images in a 1x3 grid

  

# Set size
fig, axes = plt.subplots(1, 3, figsize=(12, 5))

  

for ax in axes:
	ax.get_xaxis().set_visible(False)
	
	ax.get_yaxis().set_visible(False)

  

axes[0].imshow(img_panda)
axes[1].imshow(img_gray, cmap='gray')
axes[2].imshow(img_binary, cmap='gray')

  

# Add corresponding titles

axes[0].set_title('Original')
axes[1].set_title('Grayscale')
axes[2].set_title('Binary')


plt.tight_layout()

```


-----

## 1.4 Manipulació d'imatge
[[Rescale i Resize]]
[[#Resize i Rescale]]
### a) Centrar i rescale
Fes una imatge en negre un 15% més gran que el panda i posa el panda enmig

```python
#Your solution

  

from skimage.transform import rescale

# Create a new RGB black image 15% larger than the img_panda (in both dimensions)

# First we create a black image with the desired size

img_panda_black = np.zeros((int(img_panda.shape[0]*1.15), int(img_panda.shape[1]*1.15), 3), dtype=np.uint8)


# Embed the panga image in the center of the black image

img_panda_black[img_panda_black.shape[0]//2-img_panda.shape[0]//2:img_panda_black.shape[0]//2+img_panda.shape[0]//2,

img_panda_black.shape[1]//2-img_panda.shape[1]//2:img_panda_black.shape[1]//2+img_panda.shape[1]//2] = img_panda

  

plt.imshow(img_panda_black)
plt.axis('off')

```

#### Alternatives
##### 1 - rescale
```python
# ALternatively using the skimage rescale function

img_panda_black = rescale(img_panda, 1.15)

img_panda_black = img_panda_black * 0 

# If suing rescale, we need to convert the image to uint8
```

##### 2 - Slicing
```python
# or using slicing
 img_panda_black[:,:] = 0

```

### b) Canvi color frame
```python
# Change the color of the frame to green

img_panda_green = img_panda_black.copy()

img_panda_green[:,:,1] = 255

  

# Embed the panga image in the center of the black image

img_panda_green[img_panda_black.shape[0]//2-img_panda.shape[0]//2:img_panda_black.shape[0]//2+img_panda.shape[0]//2,

img_panda_black.shape[1]//2-img_panda.shape[1]//2:img_panda_black.shape[1]//2+img_panda.shape[1]//2] = img_panda

  
  

# Show img_panda, img_panda_black, and img_panda_green in a 1x3 grid with titles

fig, axes = plt.subplots(1, 3, figsize=(12, 5))

  

for ax in axes:

ax.get_xaxis().set_visible(False)

ax.get_yaxis().set_visible(False)

  

axes[0].imshow(img_panda)

axes[1].imshow(img_panda_black)

axes[2].imshow(img_panda_green)

  

axes[0].set_title('Original')

axes[1].set_title('Black frame')

axes[2].set_title('Green frame')
```

----

## 1.5 Contrast

>[!note] Enhancement
> When running the function `imshow()` the image is authomatically enhanced. Use the `vmin` and `vmax` parameters in order to deactivate the enhancement applied by default. To this purpose, check the data type and used the maximum and minimum value corresponding to this type.


### a)
```python
plt.imshow(img, vmin=0, vmax=255) 
# In this exercise, using vmin and vmax is important to display the image correctly
```

##### dark contrast
```python
dark_image = img-img.min()  

plt.imshow(dark_image, vmin=0, vmax=255)
```

##### bright contrast
```python
bright_image = img + 255-img.max()

plt.imshow(bright_image, vmin=0, vmax=255)
```

### b) Millora el contrast

S'apliquen 2 mètodes aquí
```python

# Scale the image value to 0-255

minimum = img.min()
maximum = img.max()

  
# Formula
img_formula = (img-minimum)/(maximum-minimum)
print(img_formula.min(), img_formula.max())

  
# reescale
from skimage.exposure import rescale_intensity

img_rescale = rescale_intensity(img)
print(img_rescale.min(), img_rescale.max())

  

# Show the original image, the image using the formula, and the image using rescale_intensity in a 1x3 grid

fig, axes = plt.subplots(1, 3, figsize=(12, 5))
for ax in axes:	
	ax.get_xaxis().set_visible(False)
	ax.get_yaxis().set_visible(False)

  

axes[0].imshow(img, cmap='gray', vmin=0, vmax=255)
axes[1].imshow(img_formula, cmap='gray', vmin=0, vmax=1)
axes[2].imshow(img_rescale, cmap='gray', vmin=0, vmax=255)

axes[0].set_title('Original')
axes[1].set_title('Formula')
axes[2].set_title('Rescale intensity')

```




---

## Exc 2.- Càrrega i manipulació de color

### a) Canals de color

De la imatge `chairs.png`, separa i visualitza els seus tres canals de color (R, G, B) de manera individual.
![[chairs.jpg]]

```python
img = io.imread('images_notebook/chairs.jpg')
# Separem els 
R = img[:, :, 0]
G = img[:, :, 1]
B = img[:, :, 2]

# Preparem la figura per a la visualització
fig, axes = plt.subplots(1, 3, figsize=(15, 5))
titles = ['Canal Vermell', 'Canal Verd', 'Canal Blau']
channels = [R, G, B]

for i, ax in enumerate(axes):
    ax.imshow(channels[i], cmap='gray')
    ax.set_title(titles[i])
    ax.axis('off')

plt.show()
```

> [!note] Visualització de canals
> 
> Un canal de color individual és una matriu 2D, és a dir, una imatge en escala de grisos. Per això, per visualitzar-lo correctament amb imshow, hem d'utilitzar un mapa de color com cmap='gray'.



### b) Intercanvi de canals

Mostra les dimensions i Intercanvia el canal R amb el B

```python



# Read the image imaages_notebook/chairs.jpg

img = io.imread('images_notebook/chairs.jpg')

# Mostrem les dimensions
print(f"Dimensions: {img.shape}")

# Create a new image interchanging the red and blue channels

img_red_blue = img.copy()
img_red_blue[:,:,0] = img[:,:,2]
img_red_blue[:,:,2] = img[:,:,0]

  

# SHow the original and the new image in a 1x2 grid
fig, axes = plt.subplots(1, 2, figsize=(12, 5))
for ax in axes:
	ax.axis('off')

  

axes[0].imshow(img)
axes[1].imshow(img_red_blue)

axes[0].set_title('Original')
axes[1].set_title('Red and Blue Interchanged')
```


---

## Exc 2.- Superposició d'imatges amb màscares

Aquest exercici final consisteix a superposar imatges en regions concretes definides per una màscara. 

### a) Preparació: Càrrega de màscara i textura

D'una imatge amb 3 cercles, separa'ls i posals en diferents plots
![[ex16.png]]

```python
# Read the image images_notebook/circles.bmp
img = io.imread('images_notebook/circles.bmp')

# Create a mask to get only the first third of the image
img_1 = 255*np.ones_like(img)
img_1[:,:300] = img[:,:300]

# Create a mask to get only the second third of the image
img_2 = 255*np.ones_like(img)
img_2[:,300:600] = img[:,300:600]

# Create a mask to get only the last third of the image
img_3 = 255*np.ones_like(img)
img_3[:,600:] = img[:,600:]


#PLOTING
plt.imshow(img, cmap='gray')
plt.show()

# Show the three images in a 1x3 grid
fig, axes = plt.subplots(1, 3, figsize=(12, 5))

axes[0].imshow(img_1, cmap='gray', vmin=0, vmax=255)
axes[1].imshow(img_2, cmap='gray')
axes[2].imshow(img_3, cmap='gray')

axes[0].set_title('Left circle')
axes[1].set_title('Center circle')
axes[2].set_title('Right circle')
```


### b) Posar abric a una model

Fes servir la màscara per "retallar" l'abric de `coat.png` i posar-lo sobre `model.png`.

![[ex17d.png]]
#### COM FER MASCARES AMB FONDO NEGRE

```python
# Carreguem els fitxers addicionals
mask_img = io.imread('mask.png')
img_texture = io.imread('texture.png')

# La màscara booleana serà True on la imatge de màscara tingui valors > 0
# Això selecciona els píxels que NO són negres.
mask = mask_img > 0

# Visualitzem la màscara per comprovar
plt.imshow(mask, cmap='gray')
plt.title('Màscara Booleana')
plt.axis('off')
```



```python
# És crucial que les imatges tinguin les mateixes dimensions
# En aquest cas, ja les tenen (1024, 768)

# Creem una còpia de la imatge del model per no sobreescriure l'original
img_model_coat = img_model.copy()

# Fem servir la màscara per assignar els píxels de l'abric
# Només en la regió de la màscara.
img_model_coat[mask] = img_coat[mask]

# Mostrem el resultat
plt.imshow(img_model_coat)
plt.title('Model amb l\'abric superposat')
plt.axis('off')
```

### c) Superposició de la textura (`texture.png`)

Ara, en lloc de l'abric, aplica la textura a la zona de l'abric sobre el model.

```python
from skimage.transform import resize
from skimage import img_as_ubyte

# La textura té dimensions diferents, l'hem de redimensionar
img_texture_resized = resize(img_texture, img_model.shape[:2])

# La funció resize retorna valors float [0,1]. La convertim a uint8 [0,255]
img_texture_resized = img_as_ubyte(img_texture_resized)


# Creem una nova còpia del model original
img_model_texture = img_model.copy()

# Apliquem la textura redimensionada utilitzant la mateixa màscara
img_model_texture[mask] = img_texture_resized[mask]


# Mostrem el resultat final
plt.imshow(img_model_texture)
plt.title('Model amb la textura aplicada')
plt.axis('off')
```


### EXC SENCER

```python
# Read the image images_notebook/model.png
from skimage.transform import resize

  

img = io.imread('images_notebook/model.png')
img_coat = io.imread('images_notebook/coat.png')

  

# Get a mask with the non-balck pixels of the coat image
mask = img_coat[:,:,:3] > 0

# Convert the mask to a 2D mask
mask=np.max(mask, axis=2)

  

# Overlap the coat image on the model image
img_model_coat = img.copy()
img_model_coat[mask] = img_coat[mask]

  

# Read the image images_notebook/barcelona.jpg
img_texture = io.imread('images_notebook/barcelona.jpg')

# Resize it to the same size as the model image
img_texture = resize(img_texture, img.shape[:2])
img_texture = img_as_ubyte(img_texture)

  

# Mask the texture image with the mask and overlay it on the model image
img_model = img.copy()
img_model[mask,:3] = img_texture[mask]
```



> [!summary] Resum de la tècnica
> 
> L'ús de màscares booleanes per a l'indexació és una de les tècniques més potents de NumPy i, per extensió, del processament d'imatges. Permet seleccionar i modificar regions complexes d'una imatge de forma extremadament eficient i amb un codi molt llegible. El procediment és:
> 
> 1. **Crear una màscara**: Un array de la mateixa mida que la imatge amb valors `True` a les zones d'interès i `False` a la resta.
>     
> 2. **Aplicar la màscara**: Utilitzar-la per indexar tant la imatge de destí com la d'origen (`desti[mask] = origen[mask]`).


> [!summary] Conclusió del problema
> 
> Aquest exercici combina múltiples tècniques fonamentals en visió per computador:
> 
> 1. **Càrrega d'imatges**: `io.imread`.
>     
> 2. **Creació de màscares**: Selecció de regions d'interès mitjançant condicions lògiques sobre els valors dels píxels.
>     
> 3. **Manipulació de dimensions**: `resize` per ajustar la mida de les imatges.
>     
> 4. **Indexació booleana**: Ús d'una màscara per modificar selectivament els píxels d'una imatge (`img[mask] = ...`). Aquesta és una tècnica extremadament potent i eficient.


# Apunts extres

## Resize i Rescale

## Reescale

Reescala en base la imatge:
un 15% més, per exemple:
```python
rom skimage.transform import rescale


img_panda_black = rescale(img_panda, 1.15, channel_axis=-1)

```


>[!note] Chanel axis
> És bona pràctica indicar `channel_axis=-1` (o `channel_axis=2`) si la imatge és en color (RGB), per assegurar que l'escalat no s'aplica a l'eix dels canals de color.



## Resize
Agafa la imatge i li assigna la mida que li demanis:
Agafa la imatge i l'ajusta (força) a la mida exacta en píxels que li demanis. **No** manté la relació d'aspecte per defecte.

```python
from skimage.transform import resize


# 800 píxels d'alt per 600 píxels d'ample
nova_mida = (800, 600)

img_panda_resized = resize(img_panda, nova_mida)
```